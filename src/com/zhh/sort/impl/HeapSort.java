package com.zhh.sort.impl;

import com.zhh.sort.Sort;

public class HeapSort extends Sort {


    /**
     * 思路：满二叉树，用数组的第1个位置(index == 1)表示根节点，第2个、第3个位置表示根节点的两个子节点，第4、第5位置表示第2个位置的子节点...，以此类推；
     * 那么可以得出第k个节点的子节点是2k和2k+1，第k个子节点的父节点是k/2; 如果2k>n了说明这个节点是叶子节点。
     * 具体排序过程，保证节点的值始终不小于子节点（大根堆），取出根节点的值（最大值），与最后一个节点值交换后，删除最后一个节点，然后在把树排序，
     * 既保证节点的值始终不小于子节点，再取出根节点的值（第二大的值），与最后一个节点值交换后，删除最后一个节点，然后在把树排序...,重复操作，就能排序了
     *
     * 时间复杂度：n*logn
     * @param a
     */
    @Override
    public void sort(int[] a) {

    }
}
